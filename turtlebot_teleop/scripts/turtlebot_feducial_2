#!/usr/bin/env python

import rospy
import math
import time
from actionlib import SimpleActionClient
from std_msgs.msg import String
from turtlebot_teleop.srv import GetBin, GetBinRequest, GetBinResponse
from ar_track_alvar_msgs.msg import AlvarMarkers
from move_base_msgs.msg import MoveBaseActionGoal, MoveBaseActionFeedback, MoveBaseActionResult, MoveBaseAction, MoveBaseGoal, MoveBaseResult
from tf.transformations import euler_from_quaternion, quaternion_from_euler

# the distance that the turtlebot should be in front of the fiducial when it stops.
DISTANCE_FROM_FIDUCIAL = 0.6

# constants representing goal
ACTION_ACTIVE = 1
ACTION_ABORTED = 4
ACTION_SUCCEEDED = 3

# results for the service calls.
RESULT_SUCCESS = 1
RESULT_FAILURE = 0

NOT_SEEN_TIMEOUT = 5 # number of seconds to wait until we fail if we haven't seen /ar_pose_marker topic
NOT_SEEN_COUNT_TIMEOUT = 5 # number of times we should allow to not see our specific target

PUBLISHER_QUEUE_SIZE = 20 # nubmer of cmd_vel Twist() objects we should hold in the queue.

class ChockabotError(Exception):
    def __init__(self, msg):
        self.msg = msg
    def __str__(self):
        return repr(self.msg)

class FiducialServer():
    
    def __init__(self):
        self.ignore_callback = True
        self.bin_no = None
        rospy.init_node("turtlebot_feducial_2")

        self.move_client = SimpleActionClient('move_base', MoveBaseAction)
        print 'waiting for server... if it doesn"t show, run `roslaunch turtlebot_navigation 3d_amcl.launch` on the robot.'
        self.move_client.wait_for_server()
        
        self.get_service = rospy.Service('get_bin', GetBin, self.get_bin)
        # self.set_service = rospy.Service('set_bin', GetBin, self.set_bin)

        # subscribes to the topic giving us the markers and their positions.
        print 'subscribing to ar_pose_marker topic... if it doesnt continue, run `roslaunch turtlebot_teleop alvar.launch` on computer.'
        rospy.Subscriber('ar_pose_marker', AlvarMarkers, self.ar_marker_callback, queue_size=1)
        
        # publishes to the cmd_vel topic to controlt he robot.
        self.cmd_vel = rospy.Publisher('~cmd_vel', Twist, queue_size=PUBLISHER_QUEUE_SIZE)
        rospy.spin()
        
    # The service call to retrieve a bin from a shelf.
    def get_bin(self, bin_request):
        self.bin_no = bin_request.bin
        
        try:
            self.line_up_robot()
            self.advance_to_bin()
            self.pick_up_bin()
            self.reverse_from_bin()
        except ChockabotError as e:
            print 'Error: ' + e.msg
            return GetBinResponse(RESULT_FAILURE)
            
        return GetBinResponse(RESULT_SUCCESS)
        
    # the callback called when feducials are recognized.
    def ar_marker_callback(self, data):
        # If we should ignore for now, return.
        if self.ignore_callback:
            return
            
       self.data = data
        
    # method to find the target marker and timeout if it can't do it for several consecutive times.
    def find_target_marker(self):
        not_seen_count = 0

        while 1:
            self.data = None
            self.ignore_callback = False
            
            # waits for more data to arrive with a timeout.
            t = time.clock()
            while self.data == None:
                if time.clock() - t > NOT_SEEN_TIMEOUT:
                    self.ignore_callback = True
                    raise ChockabotError('timed out wating for new data from callback. fiducials topic is not running..')
                
            # checks that we can find markers
            if not len(self.data.markers):
                print 'target fiducial not seen yet..'
                not_seen_count += 1
                if not_seen_count > NOT_SEEN_COUNT_TIMEOUT
                    self.ignore_callback = True
                    raise ChockabotError('could not find fiducial after waiting NOT_SEEN_TIMEOUT times.')
                continue # tries again.
                
            target_marker = None
            for m in self.data.markers:
                if m.id == self.bin_no:
                    print 'found target marker (' + str(self.bin_no) + ') with ' + str(m.confidence), ' confidence level.'
                    target_marker = m
                    break
                    
            if target_marker == None:
                print 'Error: could not find target marker: ', self.bin_no
                not_seen_count += 1
                if not_seen_count > NOT_SEEN_COUNT_TIMEOUT
                    self.ignore_callback = True
                    raise ChockabotError('could not find target fiducial after waiting NOT_SEEN_TIMEOUT times.')
                continue
                
            break
        # begins ignoring the callback now that we have the target marker.
        self.ignore_callback = true
        return target_marker
        
    # This method puts the robot at a fixed distance away and facing exactly toward the fiducial and directly in front of the fiducial.
    def line_up_robot(self):
        # finds the target marker and returns if it can't find it.
        target_marker = self.find_target_marker()
                    
        # currently just aligns with the first marker in the sequence
        fiducial_pose = target_marker.pose.pose

        # creates the goal and assigns the position and orientation.
        new_goal = MoveBaseGoal()

        # calculates the needed 'roll' (roll of the ar pose marker is actually the yaw of the robot) to determine which way the fiducial is facing.
        yaw = euler_from_quaternion((fiducial_pose.orientation.x, fiducial_pose.orientation.y, fiducial_pose.orientation.z, fiducial_pose.orientation.w))[0]
                    
        # # the new goal's position will be DISTANCE_FROM_FIDUCIAL away, lined up exactly facing toward the fiducial.
        new_goal.target_pose.pose.position.y = -1 * ( fiducial_pose.position.x + (DISTANCE_FROM_FIDUCIAL * -1 * math.sin(yaw))) # multiplies by -1 because camera_rgb's -x is representavices of base link's x
        new_goal.target_pose.pose.position.x = fiducial_pose.position.z + (DISTANCE_FROM_FIDUCIAL * math.cos(yaw)) # uses 'z' because camera_rgb's z is actually representative of base link's y.

        # reverses orientation around to face the fiducial rather than face the same direction as the fiducial.
        yaw += math.pi
        if yaw > math.pi:
            yaw -= 2 * math.pi
        # print 'difference in angle between fiducial and robot:, ', yaw

        # assigns the orientation to look directly toward fiducial  
        new_goal.target_pose.pose.orientation.x = 0
        new_goal.target_pose.pose.orientation.y = 0
        quaternion = quaternion_from_euler(0, 0, yaw)
        new_goal.target_pose.pose.orientation.z = quaternion[2]
        new_goal.target_pose.pose.orientation.w = quaternion[3]

        # makes everything in the goal relative to 'base link' - THIS FRAME is not THE OUTPUT FRAME specified in the alvar.launch file
        new_goal.target_pose.header.frame_id = 'base_link'

        print 'sending goal to line up the robot...'
        self.move_client.send_goal(new_goal)
        self.move_client.wait_for_result()

        # Checks the status of the goal. 
        if (self.move_client.get_state() != ACTION_SUCCEEDED):
            raise ChockabotError("action to move robot failed.")
            
        print 'action to move robot succeeded.'
            
        
    # this method advances the robot slowly forward to the bin. it advances, stops, and makes sure it's in line with the fiducial.
    # if it starts going off course, it will attempt to correct itself. if it can't do so, it will back up and retry.
    def advance_to_bin(self):
        print 'advancing to bin'
        target_marker = self.find_target_marker()
                    
        fiducial_pose = target_marker.pose.pose

        # creates the goal and assigns the position and orientation to move it smoothly to the bin.
        twist = Twist()
        
        
    # this method controlls the linear actuator by lifting it up
    def pick_up_bin(self):
        print 'in state: pick up bin'
        pass
        
    # this method reverses the robot away from the bin, and transitions the service call to finished.
    # it will finish the state machine by setting self.result and self.state to done.
    def reverse_from_bin(self):
        print 'in state: reverse from bin'
        pass
        
if __name__ == '__main__':
    FiducialServer()