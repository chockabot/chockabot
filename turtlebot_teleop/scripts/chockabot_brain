#!/usr/bin/env python

import rospy
import actionlib
import easygui
import json


import turtlebot_teleop.msg
from std_msgs.msg import String
from geometry_msgs.msg import Point, PoseStamped, Pose, Quaternion
from move_base_msgs.msg import MoveBaseActionGoal, MoveBaseActionFeedback, MoveBaseActionResult, MoveBaseAction, MoveBaseGoal, MoveBaseResult

import sys, select, termios, tty, Queue

import easygui

# Constants representing goal sucess
ACTION_ACTIVE = 1
ACTION_ABORTED = 4
ACTION_SUCCEEDED = 3

class ChockabotBrain():

    ITEMS_FILE = '../items.itm' # Files located at homes/cse
    DEST_FILE = '../dest.itm'
    HOMING_PERIOD = 10

    def __init__(self, default_files=True):
        rospy.init_node('chockabot_brain')
        
        self.move_client = actionlib.SimpleActionClient('move_base', MoveBaseAction)
        print 'waiting for moving server... if it doesn"t show, run `roslaunch turtlebot_navigation 3d_amcl.launch` on the robot.'
        self.move_client.wait_for_server()
        
        self.complete_action = actionlib.SimpleActionClient('web_app', turtlebot_teleop.msg.UserCompleteAction)
        print 'waiting for server... if it doesn"t show, run `roslaunch turtlebot_teleop app.launch` on this terminal.'
        self.complete_action.wait_for_server()
        
        self.cancel_list = []        
       
        if default_files:
            self.item_loc = self.load_locs(self.ITEMS_FILE)
            self.dest_loc = self.load_locs(self.DEST_FILE)
        else:
            file_name = easygui.fileopenbox(msg="Enter items file to read", filetypes="*.itm")
            if file_name[len(file_name) - 4:len(file_name)] != '.itm':
                file_name += '.itm'
            self.item_loc = self.load_locs(file_name)
            
            file_name = easygui.fileopenbox(msg="Enter destination file to read", filetypes="*.itm")
            if file_name[len(file_name) - 4:len(file_name)] != '.itm':
                file_name += '.itm'
            self.dest_loc = self.load_locs(file_name)
            

        self.home_timer = None
        
        

        self.job_sub = rospy.Subscriber('item_requests', String, self.job_callback)
        # self.cancel_sub = rospy.Subscriber('item_cancellations', String, self.cancel_callback)

        print 'items', self.item_loc
        print 'dests', self.dest_loc
        
        self.execute_job('hillary', 'dog', 'hall')

        rospy.spin()

    # callback to handle added canceled jobs
    def cancel_callback(self, data):
        self.cancel_list.append(data)    

    # callback to handle if it runs into an object.
    def job_callback(self, data):
        rospy.loginfo(rospy.get_caller_id() + ' I heard a request for job=%s', data)

        try:
            # Extract request from received data
            name, item, destination = data.split('\t')
            
            # Verify the item and location exist
            dest_found = destination in self.dest_loc
            item_found = item in self.item_loc
            
            if dest_found and item_found:            
                # If the job has been requested to be cancelled then remove item
                # Do not execute the job
                if name in self.cancel_list:
                    self.cancel_list.remove(name)
                    rospy.loginfo(rospy.get_caller_id() + 'Job for %s was cancelled.', name)
                    
                # Else execute the job
                else:
                    if self.home_timer:
                        self.home_timer.cancel()
                    self.execute_job(name, item, destination)
                    
                    # Create a new timer
                    self.home_timer = self.create_home_timer()
            else:
                # Print an error if the item or location is not found
                not_found = 'Item' if not item_found else 'Location'
                not_found += ' and Location' if not dest_found and not item_found else ''
                rospy.logerr(rospy.get_caller_id() + ' %s not found.' , not_found)
        
        # Log an error if we have a problem reading the job from the subscription
        except Exception as e:
            rospy.loginfo(rospy.get_caller_id() + ' Unable to Read: job request not in correct format %s', e)
            
    # job execution method
    def execute_job(self, name, item, destination):
        # STEP 0: Check for validity
        if destination not in self.dest_loc or item not in self.item_loc:
            rospy.loginfo(rospy.get_caller_id() + ' did not finish job for %s: WAS NOT VALID', name)
            return
    
        # STEP 1: Go to the item location
        item_goal = MoveBaseGoal()
        item_goal.target_pose = self.item_loc[item]
        move_client.send_goal(item_goal)
        move_client.wait_for_result()
        # STEP 2: Align with Fiducial
            # TODO(Cody) Call Fiducial alignment service
        # STEP 3: Use arm to get object
            # TODO(Cody) Call arm grabbing service
        # STEP 4: Go to destination location
        dest_goal = MoveBaseGoal()
        dest_goal.target_pose = self.dest_loc[destination]
        move_client.send_goal(dest_goal)
        move_client.wait_for_result()
        # STEP 5: Send JobCompletionNotification Action (wait for completion)
        self.complete_action.wait_for_server()
        goal = turtlebot_teleop.msg.UserCompleteGoal(job=name)
        self.complete_action.send_goal(goal)
        client.wait_for_result()

        if client.get_result():
            rospy.loginfo(rospy.get_caller_id() + ' finished job for %s', name)
        else:
            rospy.loginfo(rospy.get_caller_id() + ' did not finish job for %s', name)        

    def create_home_timer(self):
        if self.home_timer:
            self.home_timer.cancel()

        # Create a new timer
        home_timer = rospy.Timer(rospy.Duration(self.HOMING_PERIOD), self.go_home_youre_drunk, True)
        
    def go_home_youre_drunk(self, feedback):
        rospy.logerr(rospy.get_caller_id() + ' timed out and headed home')
        home_goal = MoveBaseGoal()
        
        if self.dest_loc['home']:   
            home_goal.target_pose = self.dest_loc['home']
            
        # home_goal.target_pose.header.frame_id = ???
        self.move_client.send_goal(home_goal)
        self.move_client.wait_for_result()
        
        # Checks the status of the goal. 
        if (self.move_client.get_state() == ACTION_SUCCEEDED):
            # Robot made it home safe and sound, fingers crossed no hangover
            rospy.logerr(rospy.get_caller_id() + ' is home')
        else:
            # Robot was too drunk to make it home
            rospy.logerr(rospy.get_caller_id() + ' did not make it home')
        
        
    def load_locs(self, file_name):
        loaded_locs = {}
        try:
            f = open(file_name, 'r')
            new_locs = json.loads( f.read() )
            f.close()
            
            for data_name in new_locs.keys():
                pose_data = new_locs[data_name]
                
                loc_pose = Pose()
                loc_pose.position = Point(pose_data[0][0], pose_data[0][1], 0)
                if len(pose_data) > 1:
                    loc_pose.orientation.z = pose_data[1][0]
                    loc_pose.orientation.w = pose_data[1][1]
                    
                loaded_locs[data_name] = loc_pose
        except Exception as e:
            rospy.loginfo('Could not load from file %s: %s' % (file_name, e))        
        return loaded_locs

if __name__=="__main__":
    ChockabotBrain()
    
    
    